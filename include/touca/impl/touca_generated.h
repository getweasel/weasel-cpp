// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TOUCA_TOUCA_FBS_H_
#define FLATBUFFERS_GENERATED_TOUCA_TOUCA_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace touca {
namespace fbs {

    struct TypeWrapper;
    struct TypeWrapperBuilder;

    struct Bool;
    struct BoolBuilder;

    struct Int;
    struct IntBuilder;

    struct UInt;
    struct UIntBuilder;

    struct Float;
    struct FloatBuilder;

    struct Double;
    struct DoubleBuilder;

    struct String;
    struct StringBuilder;

    struct ObjectMember;
    struct ObjectMemberBuilder;

    struct Object;
    struct ObjectBuilder;

    struct Array;
    struct ArrayBuilder;

    struct Result;
    struct ResultBuilder;

    struct Assertion;
    struct AssertionBuilder;

    struct Metric;
    struct MetricBuilder;

    struct Results;
    struct ResultsBuilder;

    struct Assertions;
    struct AssertionsBuilder;

    struct Metrics;
    struct MetricsBuilder;

    struct Metadata;
    struct MetadataBuilder;

    struct Message;
    struct MessageBuilder;

    struct MessageBuffer;
    struct MessageBufferBuilder;

    struct Messages;
    struct MessagesBuilder;

    enum class Type : uint8_t {
        NONE = 0,
        Bool = 1,
        Int = 2,
        UInt = 3,
        Float = 4,
        Double = 5,
        String = 6,
        Object = 7,
        Array = 8,
        MIN = NONE,
        MAX = Array
    };

    inline const Type (&EnumValuesType())[9]
    {
        static const Type values[] = {
            Type::NONE,
            Type::Bool,
            Type::Int,
            Type::UInt,
            Type::Float,
            Type::Double,
            Type::String,
            Type::Object,
            Type::Array
        };
        return values;
    }

    inline const char* const* EnumNamesType()
    {
        static const char* const names[10] = {
            "NONE",
            "Bool",
            "Int",
            "UInt",
            "Float",
            "Double",
            "String",
            "Object",
            "Array",
            nullptr
        };
        return names;
    }

    inline const char* EnumNameType(Type e)
    {
        if (flatbuffers::IsOutRange(e, Type::NONE, Type::Array))
            return "";
        const size_t index = static_cast<size_t>(e);
        return EnumNamesType()[index];
    }

    template <typename T>
    struct TypeTraits {
        static const Type enum_value = Type::NONE;
    };

    template <>
    struct TypeTraits<touca::fbs::Bool> {
        static const Type enum_value = Type::Bool;
    };

    template <>
    struct TypeTraits<touca::fbs::Int> {
        static const Type enum_value = Type::Int;
    };

    template <>
    struct TypeTraits<touca::fbs::UInt> {
        static const Type enum_value = Type::UInt;
    };

    template <>
    struct TypeTraits<touca::fbs::Float> {
        static const Type enum_value = Type::Float;
    };

    template <>
    struct TypeTraits<touca::fbs::Double> {
        static const Type enum_value = Type::Double;
    };

    template <>
    struct TypeTraits<touca::fbs::String> {
        static const Type enum_value = Type::String;
    };

    template <>
    struct TypeTraits<touca::fbs::Object> {
        static const Type enum_value = Type::Object;
    };

    template <>
    struct TypeTraits<touca::fbs::Array> {
        static const Type enum_value = Type::Array;
    };

    bool VerifyType(flatbuffers::Verifier& verifier, const void* obj, Type type);
    bool VerifyTypeVector(flatbuffers::Verifier& verifier, const flatbuffers::Vector<flatbuffers::Offset<void>>* values, const flatbuffers::Vector<uint8_t>* types);

    enum class ResultType : uint8_t {
        Check = 1,
        Assert = 2,
        MIN = Check,
        MAX = Assert
    };

    inline const ResultType (&EnumValuesResultType())[2]
    {
        static const ResultType values[] = {
            ResultType::Check,
            ResultType::Assert
        };
        return values;
    }

    inline const char* const* EnumNamesResultType()
    {
        static const char* const names[3] = {
            "Check",
            "Assert",
            nullptr
        };
        return names;
    }

    inline const char* EnumNameResultType(ResultType e)
    {
        if (flatbuffers::IsOutRange(e, ResultType::Check, ResultType::Assert))
            return "";
        const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResultType::Check);
        return EnumNamesResultType()[index];
    }

    struct TypeWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef TypeWrapperBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE_TYPE = 4,
            VT_VALUE = 6
        };
        touca::fbs::Type value_type() const
        {
            return static_cast<touca::fbs::Type>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
        }
        const void* value() const
        {
            return GetPointer<const void*>(VT_VALUE);
        }
        template <typename T>
        const T* value_as() const;
        const touca::fbs::Bool* value_as_Bool() const
        {
            return value_type() == touca::fbs::Type::Bool ? static_cast<const touca::fbs::Bool*>(value()) : nullptr;
        }
        const touca::fbs::Int* value_as_Int() const
        {
            return value_type() == touca::fbs::Type::Int ? static_cast<const touca::fbs::Int*>(value()) : nullptr;
        }
        const touca::fbs::UInt* value_as_UInt() const
        {
            return value_type() == touca::fbs::Type::UInt ? static_cast<const touca::fbs::UInt*>(value()) : nullptr;
        }
        const touca::fbs::Float* value_as_Float() const
        {
            return value_type() == touca::fbs::Type::Float ? static_cast<const touca::fbs::Float*>(value()) : nullptr;
        }
        const touca::fbs::Double* value_as_Double() const
        {
            return value_type() == touca::fbs::Type::Double ? static_cast<const touca::fbs::Double*>(value()) : nullptr;
        }
        const touca::fbs::String* value_as_String() const
        {
            return value_type() == touca::fbs::Type::String ? static_cast<const touca::fbs::String*>(value()) : nullptr;
        }
        const touca::fbs::Object* value_as_Object() const
        {
            return value_type() == touca::fbs::Type::Object ? static_cast<const touca::fbs::Object*>(value()) : nullptr;
        }
        const touca::fbs::Array* value_as_Array() const
        {
            return value_type() == touca::fbs::Type::Array ? static_cast<const touca::fbs::Array*>(value()) : nullptr;
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) && VerifyOffset(verifier, VT_VALUE) && VerifyType(verifier, value(), value_type()) && verifier.EndTable();
        }
    };

    template <>
    inline const touca::fbs::Bool* TypeWrapper::value_as<touca::fbs::Bool>() const
    {
        return value_as_Bool();
    }

    template <>
    inline const touca::fbs::Int* TypeWrapper::value_as<touca::fbs::Int>() const
    {
        return value_as_Int();
    }

    template <>
    inline const touca::fbs::UInt* TypeWrapper::value_as<touca::fbs::UInt>() const
    {
        return value_as_UInt();
    }

    template <>
    inline const touca::fbs::Float* TypeWrapper::value_as<touca::fbs::Float>() const
    {
        return value_as_Float();
    }

    template <>
    inline const touca::fbs::Double* TypeWrapper::value_as<touca::fbs::Double>() const
    {
        return value_as_Double();
    }

    template <>
    inline const touca::fbs::String* TypeWrapper::value_as<touca::fbs::String>() const
    {
        return value_as_String();
    }

    template <>
    inline const touca::fbs::Object* TypeWrapper::value_as<touca::fbs::Object>() const
    {
        return value_as_Object();
    }

    template <>
    inline const touca::fbs::Array* TypeWrapper::value_as<touca::fbs::Array>() const
    {
        return value_as_Array();
    }

    struct TypeWrapperBuilder {
        typedef TypeWrapper Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value_type(touca::fbs::Type value_type)
        {
            fbb_.AddElement<uint8_t>(TypeWrapper::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
        }
        void add_value(flatbuffers::Offset<void> value)
        {
            fbb_.AddOffset(TypeWrapper::VT_VALUE, value);
        }
        explicit TypeWrapperBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TypeWrapper> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TypeWrapper>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TypeWrapper> CreateTypeWrapper(
        flatbuffers::FlatBufferBuilder& _fbb,
        touca::fbs::Type value_type = touca::fbs::Type::NONE,
        flatbuffers::Offset<void> value = 0)
    {
        TypeWrapperBuilder builder_(_fbb);
        builder_.add_value(value);
        builder_.add_value_type(value_type);
        return builder_.Finish();
    }

    struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef BoolBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        bool value() const
        {
            return GetField<uint8_t>(VT_VALUE, 0) != 0;
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE) && verifier.EndTable();
        }
    };

    struct BoolBuilder {
        typedef Bool Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(bool value)
        {
            fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
        }
        explicit BoolBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Bool> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Bool>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Bool> CreateBool(
        flatbuffers::FlatBufferBuilder& _fbb,
        bool value = false)
    {
        BoolBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef IntBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        int64_t value() const
        {
            return GetField<int64_t>(VT_VALUE, 0);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) && verifier.EndTable();
        }
    };

    struct IntBuilder {
        typedef Int Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(int64_t value)
        {
            fbb_.AddElement<int64_t>(Int::VT_VALUE, value, 0);
        }
        explicit IntBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Int> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Int>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Int> CreateInt(
        flatbuffers::FlatBufferBuilder& _fbb,
        int64_t value = 0)
    {
        IntBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct UInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef UIntBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        uint64_t value() const
        {
            return GetField<uint64_t>(VT_VALUE, 0);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_VALUE) && verifier.EndTable();
        }
    };

    struct UIntBuilder {
        typedef UInt Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(uint64_t value)
        {
            fbb_.AddElement<uint64_t>(UInt::VT_VALUE, value, 0);
        }
        explicit UIntBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UInt> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UInt>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UInt> CreateUInt(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint64_t value = 0)
    {
        UIntBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef FloatBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        float value() const
        {
            return GetField<float>(VT_VALUE, 0.0f);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_VALUE) && verifier.EndTable();
        }
    };

    struct FloatBuilder {
        typedef Float Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(float value)
        {
            fbb_.AddElement<float>(Float::VT_VALUE, value, 0.0f);
        }
        explicit FloatBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Float> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Float>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Float> CreateFloat(
        flatbuffers::FlatBufferBuilder& _fbb,
        float value = 0.0f)
    {
        FloatBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef DoubleBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        double value() const
        {
            return GetField<double>(VT_VALUE, 0.0);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
        }
    };

    struct DoubleBuilder {
        typedef Double Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(double value)
        {
            fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
        }
        explicit DoubleBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Double> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Double>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Double> CreateDouble(
        flatbuffers::FlatBufferBuilder& _fbb,
        double value = 0.0)
    {
        DoubleBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef StringBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUE = 4
        };
        const flatbuffers::String* value() const
        {
            return GetPointer<const flatbuffers::String*>(VT_VALUE);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) && verifier.VerifyString(value()) && verifier.EndTable();
        }
    };

    struct StringBuilder {
        typedef String Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(flatbuffers::Offset<flatbuffers::String> value)
        {
            fbb_.AddOffset(String::VT_VALUE, value);
        }
        explicit StringBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<String> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<String>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<String> CreateString(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> value = 0)
    {
        StringBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<String> CreateStringDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* value = nullptr)
    {
        auto value__ = value ? _fbb.CreateString(value) : 0;
        return touca::fbs::CreateString(
            _fbb,
            value__);
    }

    struct ObjectMember FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ObjectMemberBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_NAME = 4,
            VT_VALUE = 6
        };
        const flatbuffers::String* name() const
        {
            return GetPointer<const flatbuffers::String*>(VT_NAME);
        }
        const touca::fbs::TypeWrapper* value() const
        {
            return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) && VerifyOffset(verifier, VT_VALUE) && verifier.VerifyTable(value()) && verifier.EndTable();
        }
    };

    struct ObjectMemberBuilder {
        typedef ObjectMember Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_name(flatbuffers::Offset<flatbuffers::String> name)
        {
            fbb_.AddOffset(ObjectMember::VT_NAME, name);
        }
        void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value)
        {
            fbb_.AddOffset(ObjectMember::VT_VALUE, value);
        }
        explicit ObjectMemberBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ObjectMember> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ObjectMember>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ObjectMember> CreateObjectMember(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> name = 0,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0)
    {
        ObjectMemberBuilder builder_(_fbb);
        builder_.add_value(value);
        builder_.add_name(name);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<ObjectMember> CreateObjectMemberDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* name = nullptr,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0)
    {
        auto name__ = name ? _fbb.CreateString(name) : 0;
        return touca::fbs::CreateObjectMember(
            _fbb,
            name__,
            value);
    }

    struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ObjectBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_KEY = 4,
            VT_VALUES = 6
        };
        const flatbuffers::String* key() const
        {
            return GetPointer<const flatbuffers::String*>(VT_KEY);
        }
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>* values() const
        {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>*>(VT_VALUES);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) && verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUES) && verifier.VerifyVector(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
        }
    };

    struct ObjectBuilder {
        typedef Object Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_key(flatbuffers::Offset<flatbuffers::String> key)
        {
            fbb_.AddOffset(Object::VT_KEY, key);
        }
        void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>> values)
        {
            fbb_.AddOffset(Object::VT_VALUES, values);
        }
        explicit ObjectBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Object> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Object>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Object> CreateObject(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> key = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>> values = 0)
    {
        ObjectBuilder builder_(_fbb);
        builder_.add_values(values);
        builder_.add_key(key);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Object> CreateObjectDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* key = nullptr,
        const std::vector<flatbuffers::Offset<touca::fbs::ObjectMember>>* values = nullptr)
    {
        auto key__ = key ? _fbb.CreateString(key) : 0;
        auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::ObjectMember>>(*values) : 0;
        return touca::fbs::CreateObject(
            _fbb,
            key__,
            values__);
    }

    struct Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ArrayBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VALUES = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>* values() const
        {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>*>(VT_VALUES);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) && verifier.VerifyVector(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
        }
    };

    struct ArrayBuilder {
        typedef Array Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>> values)
        {
            fbb_.AddOffset(Array::VT_VALUES, values);
        }
        explicit ArrayBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Array> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Array>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Array> CreateArray(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>> values = 0)
    {
        ArrayBuilder builder_(_fbb);
        builder_.add_values(values);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Array> CreateArrayDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>* values = nullptr)
    {
        auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::TypeWrapper>>(*values) : 0;
        return touca::fbs::CreateArray(
            _fbb,
            values__);
    }

    struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ResultBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_KEY = 4,
            VT_VALUE = 6,
            VT_TYP = 8
        };
        const flatbuffers::String* key() const
        {
            return GetPointer<const flatbuffers::String*>(VT_KEY);
        }
        const touca::fbs::TypeWrapper* value() const
        {
            return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
        }
        touca::fbs::ResultType typ() const
        {
            return static_cast<touca::fbs::ResultType>(GetField<uint8_t>(VT_TYP, 1));
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) && verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUE) && verifier.VerifyTable(value()) && VerifyField<uint8_t>(verifier, VT_TYP) && verifier.EndTable();
        }
    };

    struct ResultBuilder {
        typedef Result Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_key(flatbuffers::Offset<flatbuffers::String> key)
        {
            fbb_.AddOffset(Result::VT_KEY, key);
        }
        void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value)
        {
            fbb_.AddOffset(Result::VT_VALUE, value);
        }
        void add_typ(touca::fbs::ResultType typ)
        {
            fbb_.AddElement<uint8_t>(Result::VT_TYP, static_cast<uint8_t>(typ), 1);
        }
        explicit ResultBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Result> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Result>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Result> CreateResult(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> key = 0,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0,
        touca::fbs::ResultType typ = touca::fbs::ResultType::Check)
    {
        ResultBuilder builder_(_fbb);
        builder_.add_value(value);
        builder_.add_key(key);
        builder_.add_typ(typ);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Result> CreateResultDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* key = nullptr,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0,
        touca::fbs::ResultType typ = touca::fbs::ResultType::Check)
    {
        auto key__ = key ? _fbb.CreateString(key) : 0;
        return touca::fbs::CreateResult(
            _fbb,
            key__,
            value,
            typ);
    }

    struct Assertion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef AssertionBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {

        };
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && verifier.EndTable();
        }
    };

    struct AssertionBuilder {
        typedef Assertion Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        explicit AssertionBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Assertion> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Assertion>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Assertion> CreateAssertion(
        flatbuffers::FlatBufferBuilder& _fbb)
    {
        AssertionBuilder builder_(_fbb);
        return builder_.Finish();
    }

    struct Metric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MetricBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_KEY = 4,
            VT_VALUE = 6
        };
        const flatbuffers::String* key() const
        {
            return GetPointer<const flatbuffers::String*>(VT_KEY);
        }
        const touca::fbs::TypeWrapper* value() const
        {
            return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) && verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUE) && verifier.VerifyTable(value()) && verifier.EndTable();
        }
    };

    struct MetricBuilder {
        typedef Metric Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_key(flatbuffers::Offset<flatbuffers::String> key)
        {
            fbb_.AddOffset(Metric::VT_KEY, key);
        }
        void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value)
        {
            fbb_.AddOffset(Metric::VT_VALUE, value);
        }
        explicit MetricBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Metric> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Metric>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Metric> CreateMetric(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> key = 0,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0)
    {
        MetricBuilder builder_(_fbb);
        builder_.add_value(value);
        builder_.add_key(key);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Metric> CreateMetricDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* key = nullptr,
        flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0)
    {
        auto key__ = key ? _fbb.CreateString(key) : 0;
        return touca::fbs::CreateMetric(
            _fbb,
            key__,
            value);
    }

    struct Results FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ResultsBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_ENTRIES = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>* entries() const
        {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>*>(VT_ENTRIES);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ENTRIES) && verifier.VerifyVector(entries()) && verifier.VerifyVectorOfTables(entries()) && verifier.EndTable();
        }
    };

    struct ResultsBuilder {
        typedef Results Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>> entries)
        {
            fbb_.AddOffset(Results::VT_ENTRIES, entries);
        }
        explicit ResultsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Results> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Results>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Results> CreateResults(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>> entries = 0)
    {
        ResultsBuilder builder_(_fbb);
        builder_.add_entries(entries);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Results> CreateResultsDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<touca::fbs::Result>>* entries = nullptr)
    {
        auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::Result>>(*entries) : 0;
        return touca::fbs::CreateResults(
            _fbb,
            entries__);
    }

    struct Assertions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef AssertionsBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {

        };
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && verifier.EndTable();
        }
    };

    struct AssertionsBuilder {
        typedef Assertions Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        explicit AssertionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Assertions> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Assertions>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Assertions> CreateAssertions(
        flatbuffers::FlatBufferBuilder& _fbb)
    {
        AssertionsBuilder builder_(_fbb);
        return builder_.Finish();
    }

    struct Metrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MetricsBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_ENTRIES = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>* entries() const
        {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>*>(VT_ENTRIES);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ENTRIES) && verifier.VerifyVector(entries()) && verifier.VerifyVectorOfTables(entries()) && verifier.EndTable();
        }
    };

    struct MetricsBuilder {
        typedef Metrics Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>> entries)
        {
            fbb_.AddOffset(Metrics::VT_ENTRIES, entries);
        }
        explicit MetricsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Metrics> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Metrics>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Metrics> CreateMetrics(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>> entries = 0)
    {
        MetricsBuilder builder_(_fbb);
        builder_.add_entries(entries);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Metrics> CreateMetricsDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<touca::fbs::Metric>>* entries = nullptr)
    {
        auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::Metric>>(*entries) : 0;
        return touca::fbs::CreateMetrics(
            _fbb,
            entries__);
    }

    struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MetadataBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_TESTSUITE = 4,
            VT_VERSION = 6,
            VT_TESTCASE = 10,
            VT_BUILTAT = 12,
            VT_TEAMSLUG = 14
        };
        const flatbuffers::String* testsuite() const
        {
            return GetPointer<const flatbuffers::String*>(VT_TESTSUITE);
        }
        const flatbuffers::String* version() const
        {
            return GetPointer<const flatbuffers::String*>(VT_VERSION);
        }
        const flatbuffers::String* testcase() const
        {
            return GetPointer<const flatbuffers::String*>(VT_TESTCASE);
        }
        const flatbuffers::String* builtAt() const
        {
            return GetPointer<const flatbuffers::String*>(VT_BUILTAT);
        }
        const flatbuffers::String* teamslug() const
        {
            return GetPointer<const flatbuffers::String*>(VT_TEAMSLUG);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TESTSUITE) && verifier.VerifyString(testsuite()) && VerifyOffset(verifier, VT_VERSION) && verifier.VerifyString(version()) && VerifyOffset(verifier, VT_TESTCASE) && verifier.VerifyString(testcase()) && VerifyOffset(verifier, VT_BUILTAT) && verifier.VerifyString(builtAt()) && VerifyOffset(verifier, VT_TEAMSLUG) && verifier.VerifyString(teamslug()) && verifier.EndTable();
        }
    };

    struct MetadataBuilder {
        typedef Metadata Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_testsuite(flatbuffers::Offset<flatbuffers::String> testsuite)
        {
            fbb_.AddOffset(Metadata::VT_TESTSUITE, testsuite);
        }
        void add_version(flatbuffers::Offset<flatbuffers::String> version)
        {
            fbb_.AddOffset(Metadata::VT_VERSION, version);
        }
        void add_testcase(flatbuffers::Offset<flatbuffers::String> testcase)
        {
            fbb_.AddOffset(Metadata::VT_TESTCASE, testcase);
        }
        void add_builtAt(flatbuffers::Offset<flatbuffers::String> builtAt)
        {
            fbb_.AddOffset(Metadata::VT_BUILTAT, builtAt);
        }
        void add_teamslug(flatbuffers::Offset<flatbuffers::String> teamslug)
        {
            fbb_.AddOffset(Metadata::VT_TEAMSLUG, teamslug);
        }
        explicit MetadataBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Metadata> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Metadata>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Metadata> CreateMetadata(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> testsuite = 0,
        flatbuffers::Offset<flatbuffers::String> version = 0,
        flatbuffers::Offset<flatbuffers::String> testcase = 0,
        flatbuffers::Offset<flatbuffers::String> builtAt = 0,
        flatbuffers::Offset<flatbuffers::String> teamslug = 0)
    {
        MetadataBuilder builder_(_fbb);
        builder_.add_teamslug(teamslug);
        builder_.add_builtAt(builtAt);
        builder_.add_testcase(testcase);
        builder_.add_version(version);
        builder_.add_testsuite(testsuite);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* testsuite = nullptr,
        const char* version = nullptr,
        const char* testcase = nullptr,
        const char* builtAt = nullptr,
        const char* teamslug = nullptr)
    {
        auto testsuite__ = testsuite ? _fbb.CreateString(testsuite) : 0;
        auto version__ = version ? _fbb.CreateString(version) : 0;
        auto testcase__ = testcase ? _fbb.CreateString(testcase) : 0;
        auto builtAt__ = builtAt ? _fbb.CreateString(builtAt) : 0;
        auto teamslug__ = teamslug ? _fbb.CreateString(teamslug) : 0;
        return touca::fbs::CreateMetadata(
            _fbb,
            testsuite__,
            version__,
            testcase__,
            builtAt__,
            teamslug__);
    }

    struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MessageBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_METADATA = 4,
            VT_RESULTS = 6,
            VT_METRICS = 10
        };
        const touca::fbs::Metadata* metadata() const
        {
            return GetPointer<const touca::fbs::Metadata*>(VT_METADATA);
        }
        const touca::fbs::Results* results() const
        {
            return GetPointer<const touca::fbs::Results*>(VT_RESULTS);
        }
        const touca::fbs::Metrics* metrics() const
        {
            return GetPointer<const touca::fbs::Metrics*>(VT_METRICS);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_METADATA) && verifier.VerifyTable(metadata()) && VerifyOffset(verifier, VT_RESULTS) && verifier.VerifyTable(results()) && VerifyOffset(verifier, VT_METRICS) && verifier.VerifyTable(metrics()) && verifier.EndTable();
        }
    };

    struct MessageBuilder {
        typedef Message Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_metadata(flatbuffers::Offset<touca::fbs::Metadata> metadata)
        {
            fbb_.AddOffset(Message::VT_METADATA, metadata);
        }
        void add_results(flatbuffers::Offset<touca::fbs::Results> results)
        {
            fbb_.AddOffset(Message::VT_RESULTS, results);
        }
        void add_metrics(flatbuffers::Offset<touca::fbs::Metrics> metrics)
        {
            fbb_.AddOffset(Message::VT_METRICS, metrics);
        }
        explicit MessageBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Message> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Message>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Message> CreateMessage(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<touca::fbs::Metadata> metadata = 0,
        flatbuffers::Offset<touca::fbs::Results> results = 0,
        flatbuffers::Offset<touca::fbs::Metrics> metrics = 0)
    {
        MessageBuilder builder_(_fbb);
        builder_.add_metrics(metrics);
        builder_.add_results(results);
        builder_.add_metadata(metadata);
        return builder_.Finish();
    }

    struct MessageBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MessageBufferBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_BUF = 4
        };
        const flatbuffers::Vector<uint8_t>* buf() const
        {
            return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_BUF);
        }
        const touca::fbs::Message* buf_nested_root() const
        {
            return flatbuffers::GetRoot<touca::fbs::Message>(buf()->Data());
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BUF) && verifier.VerifyVector(buf()) && verifier.EndTable();
        }
    };

    struct MessageBufferBuilder {
        typedef MessageBuffer Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_buf(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buf)
        {
            fbb_.AddOffset(MessageBuffer::VT_BUF, buf);
        }
        explicit MessageBufferBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<MessageBuffer> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<MessageBuffer>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<MessageBuffer> CreateMessageBuffer(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buf = 0)
    {
        MessageBufferBuilder builder_(_fbb);
        builder_.add_buf(buf);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<MessageBuffer> CreateMessageBufferDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<uint8_t>* buf = nullptr)
    {
        auto buf__ = buf ? _fbb.CreateVector<uint8_t>(*buf) : 0;
        return touca::fbs::CreateMessageBuffer(
            _fbb,
            buf__);
    }

    struct Messages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef MessagesBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_MESSAGES = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>* messages() const
        {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>*>(VT_MESSAGES);
        }
        bool Verify(flatbuffers::Verifier& verifier) const
        {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MESSAGES) && verifier.VerifyVector(messages()) && verifier.VerifyVectorOfTables(messages()) && verifier.EndTable();
        }
    };

    struct MessagesBuilder {
        typedef Messages Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>> messages)
        {
            fbb_.AddOffset(Messages::VT_MESSAGES, messages);
        }
        explicit MessagesBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb)
        {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Messages> Finish()
        {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Messages>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Messages> CreateMessages(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>> messages = 0)
    {
        MessagesBuilder builder_(_fbb);
        builder_.add_messages(messages);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Messages> CreateMessagesDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>* messages = nullptr)
    {
        auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::MessageBuffer>>(*messages) : 0;
        return touca::fbs::CreateMessages(
            _fbb,
            messages__);
    }

    inline bool VerifyType(flatbuffers::Verifier& verifier, const void* obj, Type type)
    {
        switch (type) {
        case Type::NONE: {
            return true;
        }
        case Type::Bool: {
            auto ptr = reinterpret_cast<const touca::fbs::Bool*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::Int: {
            auto ptr = reinterpret_cast<const touca::fbs::Int*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::UInt: {
            auto ptr = reinterpret_cast<const touca::fbs::UInt*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::Float: {
            auto ptr = reinterpret_cast<const touca::fbs::Float*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::Double: {
            auto ptr = reinterpret_cast<const touca::fbs::Double*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::String: {
            auto ptr = reinterpret_cast<const touca::fbs::String*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::Object: {
            auto ptr = reinterpret_cast<const touca::fbs::Object*>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Type::Array: {
            auto ptr = reinterpret_cast<const touca::fbs::Array*>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
        }
    }

    inline bool VerifyTypeVector(flatbuffers::Verifier& verifier, const flatbuffers::Vector<flatbuffers::Offset<void>>* values, const flatbuffers::Vector<uint8_t>* types)
    {
        if (!values || !types)
            return !values && !types;
        if (values->size() != types->size())
            return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyType(
                    verifier, values->Get(i), types->GetEnum<Type>(i))) {
                return false;
            }
        }
        return true;
    }

    inline const touca::fbs::Messages* GetMessages(const void* buf)
    {
        return flatbuffers::GetRoot<touca::fbs::Messages>(buf);
    }

    inline const touca::fbs::Messages* GetSizePrefixedMessages(const void* buf)
    {
        return flatbuffers::GetSizePrefixedRoot<touca::fbs::Messages>(buf);
    }

    inline bool VerifyMessagesBuffer(
        flatbuffers::Verifier& verifier)
    {
        return verifier.VerifyBuffer<touca::fbs::Messages>(nullptr);
    }

    inline bool VerifySizePrefixedMessagesBuffer(
        flatbuffers::Verifier& verifier)
    {
        return verifier.VerifySizePrefixedBuffer<touca::fbs::Messages>(nullptr);
    }

    inline void FinishMessagesBuffer(
        flatbuffers::FlatBufferBuilder& fbb,
        flatbuffers::Offset<touca::fbs::Messages> root)
    {
        fbb.Finish(root);
    }

    inline void FinishSizePrefixedMessagesBuffer(
        flatbuffers::FlatBufferBuilder& fbb,
        flatbuffers::Offset<touca::fbs::Messages> root)
    {
        fbb.FinishSizePrefixed(root);
    }

} // namespace fbs
} // namespace touca

#endif // FLATBUFFERS_GENERATED_TOUCA_TOUCA_FBS_H_
